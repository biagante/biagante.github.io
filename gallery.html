<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Gallery with Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: flex;
        }
        .gallery-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div class="gallery-container">
        <div id="gallery"></div> <!-- Container for the gallery -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Set up scene
        var scene = new THREE.Scene();
        var camera = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 1, 1000);

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        var galleryContainer = document.getElementById('gallery');
        galleryContainer.appendChild(renderer.domElement);

        // Add ambient light
        var ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        //create a background plane
        var bgGeometry = new THREE.PlaneGeometry(window.innerWidth * 2, window.innerHeight * 100);
        var bgMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
        var background = new THREE.Mesh(bgGeometry, bgMaterial);
        background.position.z = -100;
        scene.add(background);


        // Create gallery
        var imageWidth = 200;
        var imageHeight = 150;
        var padding = 20;
        var numRows = 20; // Number of rows
        var numCols = 3; // Number of columns

        var colors = [
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
            0xffff00, 0xff00ff, 0x00ffff,
            0xff0000, 0x00ff00, 0x0000ff,
        ]; // Placeholder colors

        colors.forEach(function(color, index) {
        var material = new THREE.MeshBasicMaterial({ color: color });
        var geometry = new THREE.PlaneGeometry(imageWidth, imageHeight);
        var plane = new THREE.Mesh(geometry, material);
        plane.originalScale = plane.scale.clone(); // Store original scale

        // Positioning each plane in a grid layout
        var row = Math.floor(index / numCols);
        var col = index % numCols;
        plane.position.x = col * (imageWidth + padding) - (imageWidth + padding);
        plane.position.y = -row * (imageHeight + padding) + (imageHeight + padding);
        
        scene.add(plane);

        // Load and apply texture to the first plane
        if (index === 0) {
            var textureLoader = new THREE.TextureLoader();
            textureLoader.load('../assets/slide1.jpg', function(texture) {
                // Scale the plane to match the aspect ratio of the loaded texture
                var aspectRatio = texture.image.width / texture.image.height;
                plane.scale.set(imageWidth * aspectRatio, imageHeight, 1);

                var material = new THREE.MeshBasicMaterial({ map: texture });
                plane.material = material;
            });
        }

        if (index === 2) {
            var textureLoader = new THREE.TextureLoader();
            textureLoader.load('../assets/slide2.jpg', function(texture) {
                // Scale the plane to match the aspect ratio of the loaded texture
                var aspectRatio = texture.image.width / texture.image.height;
                plane.scale.set(imageWidth * aspectRatio, imageHeight, 1);

                var material = new THREE.MeshBasicMaterial({ map: texture });
                plane.material = material;
            });
        }
    });


        // Position camera
        camera.position.z = 5;

        var raycaster = new THREE.Raycaster();
        var mouseVector = new THREE.Vector2();
        var maxPlaneDisplacement = 50; // Maximum displacement of the plane

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouseVector.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update raycaster with mouse position
            raycaster.setFromCamera(mouseVector, camera);

            // Check for intersections with the planes
            var intersects = raycaster.intersectObjects(scene.children, true);

            // If intersection found, zoom in the plane slightly
            if (intersects.length > 0) {
                // Reset scale of previously intersected planes
                scene.children.forEach(function(child) {
                    if (child.isMesh) {
                        child.scale.set(1, 1, 1);
                    }
                });

                // Scale the intersected plane
                intersects[0].object.scale.set(1.1, 1.1, 1.1); // Adjust the scale factor as needed
            }
        }

        var maxVerticalPosition = 50; // Adjust as needed
        var minVerticalPosition = -200 * numRows; // Adjust as needed

        function updateCameraPosition() {
            // Calculate new camera position
            var newPositionY = camera.position.y + mouseVector.y * 10; // Adjust speed as needed

            // Apply maximum and minimum limits
            if (newPositionY > maxVerticalPosition) {
                camera.position.y = maxVerticalPosition;
            } else if (newPositionY < minVerticalPosition) {
                camera.position.y = minVerticalPosition;
            } else {
                camera.position.y = newPositionY;
            }
        }

        function toggleFullscreen(plane) {
            if (!plane.isFullScreen) {
                var fullscreenPlane = plane.clone();
                fullscreenPlane.scale.set(4, 3, 1);
                fullscreenPlane.position.set(0, plane.position.y, -1);

                // Disable depth testing for the fullscreen plane
                fullscreenPlane.material.depthTest = false;
                fullscreenPlane.renderOrder = Number.MAX_SAFE_INTEGER; // Ensure it's rendered last

                scene.add(fullscreenPlane);
                plane.isFullScreen = true;
            } else {
                scene.remove(scene.children[scene.children.length - 1]);
                plane.isFullScreen = false;
            }
        }


        // Listen for mouse move events
        document.addEventListener('mousemove', onMouseMove, false);
        
        // Listen for click events
        document.addEventListener('click', function(event) {
            // Update raycaster with mouse position
            raycaster.setFromCamera(mouseVector, camera);

            // Check for intersections with the planes
            var intersects = raycaster.intersectObjects(scene.children, true);

            // If intersection found, toggle fullscreen
            if (intersects.length > 0) {
                toggleFullscreen(intersects[0].object);
            }
        }, false);

        // Render the scene
        function animate() {
            requestAnimationFrame(animate);

            // Update camera position
            updateCameraPosition();

            // Render the scene
            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>
</html>
